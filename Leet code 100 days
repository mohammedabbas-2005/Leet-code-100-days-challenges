DAY 1 C++
You are given a positive number n.

Return the smallest number x greater than or equal to n, such that the binary representation of x contains only set bits 

Example 1:

Input: n = 5

Output: 7

Explanation:

The binary representation of 7 is "111".

Example 2:

Input: n = 10

Output: 15

Explanation:

The binary representation of 15 is "1111".

Example 3:

Input: n = 3

Output: 3

Explanation:

The binary representation of 3 is "11".

 

Constraints:

1 <= n <= 1000

solutions:
class Solution {
public:
    int smallestNumber(int n) {
        int x = n;
        while ((x & (x + 1)) != 0) {
            x++;
        }
        return x;
    }
};

DAY2:
Minimum number of increment on subarray to form a target array
solution:
class Solution {
public:
    int minNumberOperations(vector<int>& target) {
        int count = target[0];
        for (int i = 1; i < target.size(); i++)
            count += max(target[i] - target[i - 1], 0);
        return count;
    }
};
DAY 3:
You are given two integers m and n representing a 0-indexed m x n grid. You are also given two 2D integer arrays guards and walls where guards[i] = [rowi, coli] and walls[j] = [rowj, colj] represent the positions of the ith guard and jth wall respectively.

A guard can see every cell in the four cardinal directions (north, east, south, or west) starting from their position unless obstructed by a wall or another guard. A cell is guarded if there is at least one guard that can see it.

Return the number of unoccupied cells that are not guarded.

Solution:
class Solution {
public:
    void dfs(int r, int c, string dir, vector<vector<int>>& vis, map<pair<int, int>, int>& mp){
        int n = vis.size();
        int m = vis[0].size();
        if(r<0 || c<0 || r>=n || c>=m) return;
        if(mp.find({r, c})!=mp.end()) return;
        else vis[r][c] = 1;

        if(dir == "r"){
            dfs(r, c+1, "r", vis, mp);
        }
        if(dir == "l"){
            dfs(r, c-1, "l", vis, mp);
        }
        if(dir == "u"){
            dfs(r-1, c, "u", vis, mp);
        }
        if(dir == "d"){
            dfs(r+1, c, "d", vis, mp);
        }
    }
    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        vector<vector<int>> vis(m, vector<int> (n));
        queue<pair<int, int>> q;
        map<pair<int, int>, int> mp;
        for(auto it: guards){
            q.push({it[0], it[1]});
            mp[{it[0], it[1]}]++;
            vis[it[0]][it[1]] = 1;
        }
        for(auto it: walls) {
            mp[{it[0], it[1]}]++;
            vis[it[0]][it[1]] = 1;
        }
        for(auto it: guards){
            int r = it[0];
            int c = it[1];
            dfs(r, c+1, "r", vis, mp);
            dfs(r, c-1, "l", vis, mp);
            dfs(r+1, c, "d", vis, mp);
            dfs(r-1, c, "u", vis, mp);
        }
        int cnt=0;
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(vis[i][j] == 0) cnt++;
            }
        }
        return cnt;
    }
};

DAY 4:
Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon.

Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope.

Return the minimum time Bob needs to make the rope colorful.
Solution:
class Solution {
public:
    int minCost(string colors, vector<int>& neededTime) {
        int n = colors.size(), sum = 0;
        
        for (int i = 1; i < n; i++) {
            int maxi = 0; // largest value balloon in substring
            while (i < n and colors[i] == colors[i - 1]) {
                sum += neededTime[i - 1];
                maxi = max(maxi, neededTime[i - 1]);
                ++i;
            }
            sum += neededTime[i - 1];
            maxi = max(maxi, neededTime[i - 1]);
            if (maxi != 0) sum -= maxi;
        }
        return sum;
    }
};


