DAY 1 C++
You are given a positive number n.

Return the smallest number x greater than or equal to n, such that the binary representation of x contains only set bits 

Example 1:

Input: n = 5

Output: 7

Explanation:

The binary representation of 7 is "111".

Example 2:

Input: n = 10

Output: 15

Explanation:

The binary representation of 15 is "1111".

Example 3:

Input: n = 3

Output: 3

Explanation:

The binary representation of 3 is "11".

 

Constraints:

1 <= n <= 1000

solutions:
class Solution {
public:
    int smallestNumber(int n) {
        int x = n;
        while ((x & (x + 1)) != 0) {
            x++;
        }
        return x;
    }
};

DAY2:
Minimum number of increment on subarray to form a target array
solution:
class Solution {
public:
    int minNumberOperations(vector<int>& target) {
        int count = target[0];
        for (int i = 1; i < target.size(); i++)
            count += max(target[i] - target[i - 1], 0);
        return count;
    }
};
DAY 3:
You are given two integers m and n representing a 0-indexed m x n grid. You are also given two 2D integer arrays guards and walls where guards[i] = [rowi, coli] and walls[j] = [rowj, colj] represent the positions of the ith guard and jth wall respectively.

A guard can see every cell in the four cardinal directions (north, east, south, or west) starting from their position unless obstructed by a wall or another guard. A cell is guarded if there is at least one guard that can see it.

Return the number of unoccupied cells that are not guarded.

Solution:
class Solution {
public:
    void dfs(int r, int c, string dir, vector<vector<int>>& vis, map<pair<int, int>, int>& mp){
        int n = vis.size();
        int m = vis[0].size();
        if(r<0 || c<0 || r>=n || c>=m) return;
        if(mp.find({r, c})!=mp.end()) return;
        else vis[r][c] = 1;

        if(dir == "r"){
            dfs(r, c+1, "r", vis, mp);
        }
        if(dir == "l"){
            dfs(r, c-1, "l", vis, mp);
        }
        if(dir == "u"){
            dfs(r-1, c, "u", vis, mp);
        }
        if(dir == "d"){
            dfs(r+1, c, "d", vis, mp);
        }
    }
    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        vector<vector<int>> vis(m, vector<int> (n));
        queue<pair<int, int>> q;
        map<pair<int, int>, int> mp;
        for(auto it: guards){
            q.push({it[0], it[1]});
            mp[{it[0], it[1]}]++;
            vis[it[0]][it[1]] = 1;
        }
        for(auto it: walls) {
            mp[{it[0], it[1]}]++;
            vis[it[0]][it[1]] = 1;
        }
        for(auto it: guards){
            int r = it[0];
            int c = it[1];
            dfs(r, c+1, "r", vis, mp);
            dfs(r, c-1, "l", vis, mp);
            dfs(r+1, c, "d", vis, mp);
            dfs(r-1, c, "u", vis, mp);
        }
        int cnt=0;
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(vis[i][j] == 0) cnt++;
            }
        }
        return cnt;
    }
};

DAY 4:
Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon.

Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope.

Return the minimum time Bob needs to make the rope colorful.
Solution:
class Solution {
public:
    int minCost(string colors, vector<int>& neededTime) {
        int n = colors.size(), sum = 0;
        
        for (int i = 1; i < n; i++) {
            int maxi = 0; // largest value balloon in substring
            while (i < n and colors[i] == colors[i - 1]) {
                sum += neededTime[i - 1];
                maxi = max(maxi, neededTime[i - 1]);
                ++i;
            }
            sum += neededTime[i - 1];
            maxi = max(maxi, neededTime[i - 1]);
            if (maxi != 0) sum -= maxi;
        }
        return sum;
    }
};
DAY 5:
You are given an array nums of n integers and two integers k and x.

The x-sum of an array is calculated by the following procedure:

Count the occurrences of all elements in the array.
Keep only the occurrences of the top x most frequent elements. If two elements have the same number of occurrences, the element with the bigger value is considered more frequent.
Calculate the sum of the resulting array.
Solution:
class Solution {
public:
    using int2=pair<int, int>;
    static int x_sum( const auto& freq, int k, int x){
        auto freq2=freq;
        sort(freq2.begin(), freq2.end(), greater<int2>());
        int sum=0;
        for (int i=0; i<x; i++){
            auto [f, num]=freq2[i];
            if (f==0) break;
            sum+=num*f;
        }
        return sum;
    }
    static vector<int> findXSum(vector<int>& nums, int k, int x) {
        const int n=nums.size(), sz=n-k+1;
        vector<int> ans(sz);
        array<int2, 51> freq;
        freq.fill({0, 0});
        for(int r=0; r<k; r++){
            int z=nums[r];
            freq[z].second=z;
            freq[z].first++;
        }
        ans[0]=x_sum(freq, k, x);
        for(int l=1, r=k; l<sz; l++, r++){
            int L=nums[l-1], R=nums[r];
            freq[L].first--;
            freq[R].first++;
            freq[R].second = R;
            ans[l]=x_sum(freq, k, x);
        }
        return ans;
    }
};


auto init = []() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    return 'c';
}();
Day 6:
ou are given an array nums of n integers and two integers k and x.

The x-sum of an array is calculated by the following procedure:

Count the occurrences of all elements in the array.
Keep only the occurrences of the top x most frequent elements. If two elements have the same number of occurrences, the element with the bigger value is considered more frequent.
Calculate the sum of the resulting array.
Solution:
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        map<int, int> freq;
        multiset<pair<int, int>> top, rest;
        long long top_sum = 0;
        vector<long long> ans;

        auto balance = [&]() {
            while ((int)top.size() < x && !rest.empty()) {
                auto it = prev(rest.end());
                top.insert(*it);
                top_sum += 1LL * it->first * it->second;
                rest.erase(it);
            }
            while ((int)top.size() > x) {
                auto it = top.begin();
                top_sum -= 1LL * it->first * it->second;
                rest.insert(*it);
                top.erase(it);
            }
            while (!rest.empty() && !top.empty() && *prev(rest.end()) > *top.begin()) {
                auto it1 = prev(rest.end());
                auto it2 = top.begin();
                top_sum += 1LL * it1->first * it1->second - 1LL * it2->first * it2->second;
                rest.insert(*it2);
                top.insert(*it1);
                rest.erase(it1);
                top.erase(it2);
            }
        };

        auto add = [&](int num) {
            pair<int, int> old = {freq[num], num};
            if (top.find(old) != top.end()) {
                top.erase(top.find(old));
                top_sum -= 1LL * old.first * old.second;
            } else if (rest.find(old) != rest.end()) {
                rest.erase(rest.find(old));
            }
            freq[num]++;
            rest.insert({freq[num], num});
            balance();
        };

        auto remove = [&](int num) {
            pair<int, int> old = {freq[num], num};
            if (top.find(old) != top.end()) {
                top.erase(top.find(old));
                top_sum -= 1LL * old.first * old.second;
            } else {
                rest.erase(rest.find(old));
            }
            freq[num]--;
            if (freq[num] > 0)
                rest.insert({freq[num], num});
            else
                freq.erase(num);
            balance();
        };

        for (int i = 0; i < k; ++i) add(nums[i]);
        ans.push_back(top_sum);

        for (int i = k; i < (int)nums.size(); ++i) {
            remove(nums[i - k]);
            add(nums[i]);
            ans.push_back(top_sum);
        }

        return ans;
    }
};

DAY 7:
You are given an integer c representing c power stations, each with a unique identifier id from 1 to c (1â€‘based indexing).

These stations are interconnected via n bidirectional cables, represented by a 2D array connections, where each element connections[i] = [ui, vi] indicates a connection between station ui and station vi. Stations that are directly or indirectly connected form a power grid.
Solution:
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<int> processQueries(int c, vector<vector<int>>& connections, vector<vector<int>>& queries) {
        vector<int> parent(c + 1);
        iota(parent.begin(), parent.end(), 0);

        function<int(int)> find = [&](int x) {
            while (parent[x] != x) {
                parent[x] = parent[parent[x]];
                x = parent[x];
            }
            return x;
        };

        // Step 1: Union all connected stations
        for (auto& conn : connections) {
            int a = conn[0], b = conn[1];
            int ra = find(a), rb = find(b);
            if (ra != rb) parent[rb] = ra;
        }

        // Step 2: Build linked order within each component
        vector<int> next_node(c + 1, 0), comp_min(c + 1, 0), last(c + 1, 0);
        for (int i = 1; i <= c; ++i) {
            int r = find(i);
            if (comp_min[r] == 0) {
                comp_min[r] = i;
            } else {
                next_node[last[r]] = i;
            }
            last[r] = i;
        }

        vector<bool> offline(c + 1, false);
        vector<int> res;

        // Step 3: Process queries
        for (auto& q : queries) {
            int t = q[0], x = q[1];

            if (t == 1) { // Maintenance check
                if (!offline[x]) {
                    res.push_back(x);
                } else {
                    int r = find(x);
                    res.push_back(comp_min[r] ? comp_min[r] : -1);
                }
            } 
            else { // Station goes offline
                if (!offline[x]) {
                    offline[x] = true;
                    int r = find(x);
                    if (comp_min[r] == x) {
                        int y = next_node[x];
                        while (y && offline[y]) y = next_node[y];
                        comp_min[r] = y ? y : 0;
                    }
                }
            }
        }

        return res;
    }
};

